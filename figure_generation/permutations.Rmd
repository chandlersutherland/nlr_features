---
title: "R Notebook"
output: html_notebook
---
Author: Chandler Sutherland 
Copyright (c) Chandler Sutherland
Email: chandlersutherland@berkeley.edu

Goal: assign significance to the enrichment plots, using the singscore gene set enrichment for expression, and permutation tests for methylation and TE distance. 

```{r}
library(data.table)
library(ggplot2)
library(tidyverse)
library(openxlsx)
library(ggsignif)
library(ggpubr)
library(singscore)
library(GSEABase)
```

Read in the gene table 
```{r}
table <- readxl::read_xlsx(path="C:\\Users\\chand\\Box Sync\\Krasileva_Lab\\Research\\chandler\\Krasileva Lab\\E14\\all_gene_table.xlsx")
```

An out of the box package exists to test significance of gene sets for expression: singscore. (Fourtran 2018)
```{r}
#generate gene sets
#remove unmappable genes 
HV <- table %>% filter(HV == 'hv') %>% filter(!(Gene %in% c('AT1G58807','AT1G58848','AT1G59124','AT1G59218')))
hv_names <- HV$Gene
hv_geneset <- GeneSet(hv_names, geneIdType=SymbolIdentifier())

NONHV <- table %>% filter(HV == 'non-hv')
nonhv_names <- NONHV$Gene %>% unique()
nonhv_geneset <- GeneSet(nonhv_names, geneIdType=SymbolIdentifier())
```

This packages does analysis by sample, not on averaged biological replicates. Loading a raw TPM matrix. Then, create the ranked gene object, ranked, and score the hv gene set and the nonhv gene set. From here, generate a null distro and plot our p values 
```{r}
TPM <- read.table("C:\\Users\\chand\\Box Sync\\Krasileva_Lab\\Research\\chandler\\Krasileva Lab\\E14\\tpm_matrix.csv", header=TRUE, sep=",", row.names=2) %>% subset(select=c(-X))

ranked <- rankGenes(TPM)

hv_sing <- simpleScore(ranked, upSet=hv_geneset)
nonhv_sing <- simpleScore(ranked, nonhv_geneset)

hv_null <- generateNull(rankData=ranked, upSet=hv_geneset)
hv_p <- getPvals(hv_null, hv_sing)
plotNull(hv_null, hv_sing, hv_p, sampleNames = names(hv_p)[1:4], textSize=0.5)
```

```{r}
nonhv_null <- generateNull(rankData=ranked, upSet=nonhv_geneset)
nonhv_p <- getPvals(nonhv_null, nonhv_sing)
plotNull(nonhv_null, nonhv_sing, nonhv_p, sampleNames = names(nonhv_p)[1:4], textSize=0.5)
```

For methylation and TE distance, write a function to calculate a p value for enrichment tests by using a permutation test 
```{r}
table[2]
# first, calculate the observed value
observe <- function(df, col_index, hv_status){
  observed <- mean(df%>%filter(HV==hv_status)%>% pull(col_index)%>%na.omit()) - 
    mean(df %>% filter(HV=='all_genes')%>%pull(col_index)%>%na.omit())
  observed
}

permute <- function(df, col_index, hv_status) {
  # build null distribution
  permutation = replicate(10000, {
    df <- df %>% drop_na(col_index)
    sample_small <- df[sample(nrow(df), nrow(df[df$HV == hv_status,]) , replace = FALSE), ] # sample the size of hvNLRs
    sample_large <- df[! rownames(df) %in% rownames(sample_small), ] # sample the rest
    mean(sample_small %>% pull(col_index))-mean(sample_large %>% pull(col_index)) # get expected mean
})
  permutation
}

#p<-permute(table, 3, 'hv')
#o<-observe(table, 3, 'hv')

mean(o<p)

p_calc <- function(df, col_index){
  o <- observe(df, col_index, 'hv')
  p <- permute(df, col_index, 'hv')
  pval <- mean(o > p)
  
  o2 <- observe(df, col_index, 'non-hv')
  p2 <- permute(df, col_index, 'non-hv')
  pval2 <- mean(o2 > p2)
  
  print(paste(colnames(df)[col_index]))
  print(paste('hv_p: ', pval, ' nonhv_p:', pval2))
}

#p_calc(table, 4)
#p_calc(table, 5)
p_calc(table, 6)
p_calc(table, 7)
p_calc(table, 8)
```
```{r}
permute_hv <- permute(table, 4, 'hv')
q=quantile(permute_hv, c(.95, .05))
observe_hv <- observe(table, 4, 'hv')
ggplot() + aes(permute_hv)+ geom_histogram(colour="black", fill="white") + geom_vline(xintercept=observe_hv)+
  geom_vline(aes(xintercept=q[2]), colour="#BB0000", size=1)+
  geom_vline(aes(xintercept=q[1]), colour="#BB0000", size=1)+
  #geom_vline(aes(xintercept=observed_nhv), color='blue')+
  xlab('Permutation difference in means meth hv nlr 1000')

mean(observe_hv > permute_hv)
```

```{r}
table <- table %>% drop_na(D)
observed_nhv <- mean(table$D[table$HV == 'non-hv' ]) - mean(table$D[table$HV == 'all_genes' ])

permutation_nhv = replicate(1000, {
  sample_small <- table[sample(nrow(table), nrow(table[table$HV == 'non-hv',]) , replace = FALSE), ] # sample the size of non-hvNLRs
  sample_large <- table[! rownames(table) %in% rownames(sample_small), ] # sample the rest
  mean(sample_small$D)-mean(sample_large$D) # get expected mean
})
q=quantile(permutation_nhv, c(.05, .95))
#did this by hand, but want to plot p=.05 on the histo 

p <- ggplot() + aes(permutation_nhv)+ geom_histogram(colour="black", fill="white") + geom_vline(xintercept=observed_nhv)+
  geom_vline(aes(xintercept=q[2]), colour="#BB0000", size=1)+
  geom_vline(aes(xintercept=q[1]), colour="#BB0000", size=1)+
  geom_vline(aes(xintercept=observed_nhv), color='blue')+
  xlab('Permutation D non-hv 1000')
p

observed_hv <- mean(table$D[table$HV == 'hv' ]) - mean(table$D[table$HV == 'all_genes' ])

permutation_hv = replicate(1000, {
  sample_small <- table[sample(nrow(table), nrow(table[table$HV == 'hv',]) , replace = FALSE), ] # sample the size of non-hvNLRs
  sample_large <- table[! rownames(table) %in% rownames(sample_small), ] # sample the rest
  mean(sample_small$D)-mean(sample_large$D) # get expected mean
})
q=quantile(permutation_hv, c(.05, .95))
#did this by hand, but want to plot p=.05 on the histo 

p <- ggplot() + aes(permutation_hv)+ geom_histogram(colour="black", fill="white") + geom_vline(xintercept=observed_hv)+
  geom_vline(aes(xintercept=q[2]), colour="#BB0000", size=1)+
  geom_vline(aes(xintercept=q[1]), colour="#BB0000", size=1)+
  #geom_vline(aes(xintercept=observed_nhv), color='blue')+
  xlab('Permutation D hv 1000')
p

#check all NLRs vs Pi 
observed_nlr <- mean(table$Pi_by_lseff[table$HV != 'all_genes' ]) - mean(table$Pi_by_lseff[table$HV == 'all_genes' ], na.rm=TRUE)

permutation_nlr = replicate(1000, {
  sample_small <- table[sample(nrow(table), nrow(table[table$HV != 'all_genes',]) , replace = FALSE), ] # sample the size of NLRs
  sample_large <- table[! rownames(table) %in% rownames(sample_small), ] # sample the rest
  mean(sample_small$Pi_by_lseff)-mean(sample_large$Pi_by_lseff) # get expected mean
})
q=quantile(permutation_nlr, c(.05, .95))
#did this by hand, but want to plot p=.05 on the histo 

p <- ggplot() + aes(permutation_nlr)+ geom_histogram(colour="black", fill="white") + geom_vline(xintercept=observed_nlr)+
  geom_vline(aes(xintercept=q[2]), colour="#BB0000", size=1)+
  geom_vline(aes(xintercept=q[1]), colour="#BB0000", size=1)+
  #geom_vline(aes(xintercept=observed_nhv), color='blue')+
  xlab('Permutation Pi NLR 1000')
p

mean(observed_nlr < permutation_nlr)
```


For TE distance, also check the median: 
```{r}
observe_med <- function(df, col_index, hv_status){
  observed <- median(df%>%filter(HV==hv_status)%>%pull(col_index)%>%na.omit()) - 
    median(df %>% filter(HV=='all_genes')%>%pull(col_index)%>%na.omit())
  observed
}

permute_med <- function(df, col_index, hv_status) {
  # build null distribution
  permutation = replicate(10000, {
    df <- df %>% drop_na(col_index)
    sample_small <- df[sample(nrow(df), nrow(df[df$HV == hv_status,]) , replace = FALSE), ] # sample the size of hvNLRs
    sample_large <- df[! rownames(df) %in% rownames(sample_small), ] # sample the rest
    median(sample_small %>% pull(col_index))-median(sample_large %>% pull(col_index)) # get expected mean
})
  permutation
}

p_calc_med <- function(df, col_index){
  o <- observe_med(df, col_index, 'hv')
  p <- permute_med(df, col_index, 'hv')
  pval <- mean(o > p)
  
  o2 <- observe_med(df, col_index, 'non-hv')
  p2 <- permute_med(df, col_index, 'non-hv')
  pval2 <- mean(o2 > p2)
  
  print(paste(colnames(df)[col_index], ' median'))
  print(paste('hv_p: ', pval, ' nonhv_p:', pval2))
}

p_calc_med(table, 5)
```


A potential bias for CG methylation is the number of high coverage CGs per gene. This is on a per-sample basis. First, test the per sample significance, then weight based on CGs per gene. 
```{r}
#load the per sample methylation files 
SRR17281085 <- readxl::read_xlsx(path="C://Users//chand//Box Sync//Krasileva_Lab//Research//chandler//Krasileva Lab//E14//e14_R//SRR17281085_per_gene_meth_count.xlsx", skip=2, col_names = c('Index', 'Chrom', 'Gene', 'mean_percent_methylation', 'count'))
SRR17281086 <- readxl::read_xlsx(path="C://Users//chand//Box Sync//Krasileva_Lab//Research//chandler//Krasileva Lab//E14//e14_R//SRR17281086_per_gene_meth_count.xlsx", skip=2, col_names = c('Index', 'Chrom', 'Gene', 'mean_percent_methylation', 'count'))
SRR17281087 <- readxl::read_xlsx(path="C://Users//chand//Box Sync//Krasileva_Lab//Research//chandler//Krasileva Lab//E14//e14_R//SRR17281087_per_gene_meth_count.xlsx", skip=2, col_names = c('Index', 'Chrom', 'Gene', 'mean_percent_methylation', 'count'))
SRR17281088 <- readxl::read_xlsx(path="C://Users//chand//Box Sync//Krasileva_Lab//Research//chandler//Krasileva Lab//E14//e14_R//SRR17281088_per_gene_meth_count.xlsx", skip=2, col_names = c('Index', 'Chrom', 'Gene', 'mean_percent_methylation', 'count'))

#clean up 
samples <- list(SRR17281085, SRR17281086, SRR17281087, SRR17281088)
names(samples) <- c('SRR17281085', 'SRR17281086', 'SRR17281087', 'SRR17281088')

clean <- function(df) {
  df2 <- df %>% merge(table, by='Gene', all=TRUE)
  df2$HV <- factor(df2$HV , levels=c("all_genes", "non-hv", "hv"))
  df3 <- df2 %>% subset(select=c('Gene', 'HV', 'mean_percent_methylation', 'count')) %>%
    filter(!is.na(mean_percent_methylation))
  df3
}

clean_samples <- lapply(names(samples), function(x) clean(samples[[x]]))
names(clean_samples) <- c('SRR17281085', 'SRR17281086', 'SRR17281087', 'SRR17281088')
```
```{r}
#lapply(names(clean_samples), function(x) p_calc(clean_samples[[x]], 3))
```

The kernel density estimation computes kernel density estimates. Often shortened to KDE, it’s a technique that let’s you create a smooth curve given a set of data. So here, it's taking in my # of mappable CG sites per HV gene, and returning a density curve. 

The approxfun function returns a list of points which linearly interpolate given data points. Returns a function performing linear or constant interpolation of the given data points. Linear interpolation is a method of calculating intermediate data between known values by conceptually drawing a straight line between two adjacent known values.

Repeat the CG count weighted permutation test on all four samples: 
```{r}
#create a sampled gene list weighted by counts 
density_sample <- function(df, hv_status){
  #df <- df %>% drop_na()
  split_df <- df %>% filter(HV == hv_status)
  
  #calculate CG count density KDE function 
  d <- density(split_df$count)
  density_function <- approxfun(d)
  
  # write probabilities, and write NAs to zero as they are outliers in CG content (90+ per gene)
  probabilities <- density_function(df$count)
  probabilities[is.na(probabilities)] <- 0
  
  # sample genes, with weights according to their number of CGs, according to above function
  all_genes <- df$Gene
  sampled_genes <- data.frame(replicate(10000, sample(all_genes, size = nrow(split_df), replace = FALSE, 
                                                    prob = probabilities)))
  
  return(sampled_genes)
  }

test_nhv <- density_sample(clean_samples[[1]], 'non-hv')
table <- clean_samples[[1]]

#write function that gets the difference in means between the permuted sample and the actual 
get_mean_difference <- function(gene_list, table) {
  permute_mean <- table %>% filter(Gene %in% gene_list) %>% pull(mean_percent_methylation) %>% mean()
  actual_mean <- table %>% filter(!Gene %in% gene_list)  %>% pull(mean_percent_methylation) %>% mean()
  return(actual_mean-permute_mean)
}


get_mean_difference(test_nhv[[1]], clean_samples[[1]])
mean_diff <- actual_mean-permute_mean

#calculate the pvalue 
pval <- function(sampled_df, table, hv_status, observed){
  differences <- list()
  for (x in 1:10000) {
    x <- get_mean_difference(sampled_df[[x]], table)
    differences <- append(differences, x)
    }
  
  p_val <- mean(differences < observed)
  
  return(p_val)
}

pval(test_nhv, 'non-hv', observed_nhv)
```

```{r}
hv_sampled_genes <- lapply(names(clean_samples), function(x) density_sample(clean_samples[[x]], 'hv'))
observed_hv <- lapply(names(clean_samples), function(x) observe(clean_samples[[x]], 3, 'hv'))

pval(hv_sampled_genes[[1]], clean_samples[[1]], 'hv', observed_hv[[1]])
pval(hv_sampled_genes[[2]], clean_samples[[2]], 'hv', observed_hv[[2]])
pval(hv_sampled_genes[[3]], clean_samples[[3]], 'hv', observed_hv[[3]])
pval(hv_sampled_genes[[4]], clean_samples[[4]], 'hv', observed_hv[[4]])
```

```{r}
nhv_sampled_genes <- lapply(names(clean_samples), function(x) density_sample(clean_samples[[x]], 'non-hv'))
observed_nhv <- lapply(names(clean_samples), function(x) observe(clean_samples[[x]], 3, 'non-hv'))

pval(nhv_sampled_genes[[1]], clean_samples[[1]], 'non-hv', observed_nhv[[1]])
pval(nhv_sampled_genes[[2]], clean_samples[[2]], 'non-hv', observed_nhv[[2]])
pval(nhv_sampled_genes[[3]], clean_samples[[3]], 'non-hv', observed_nhv[[3]])
pval(nhv_sampled_genes[[4]], clean_samples[[4]], 'non-hv', observed_nhv[[4]])
```

