---
title: "R Notebook"
output: html_notebook
---
Author: Chandler Sutherland 
Copyright (c) Chandler Sutherland
Email: chandlersutherland@berkeley.edu

Goal: assign significance to the enrichment plots, using the singscore gene set enrichment for expression, and permutation tests for methylation and TE distance. 

```{r}
library(data.table)
library(ggplot2)
library(tidyverse)
library(openxlsx)
library(ggsignif)
library(ggpubr)
library(singscore)
library(GSEABase)
```

Read in the gene table 
```{r}
table <- readxl::read_xlsx(path="C:\\Users\\chand\\Box Sync\\Krasileva_Lab\\Research\\chandler\\Krasileva Lab\\E14\\all_gene_table.xlsx")
```

An out of the box package exists to test significance of gene sets for expression: singscore. (Fourtran 2018)
```{r}
#generate gene sets
#remove unmappable genes 
HV <- table %>% filter(HV == 'hv') %>% filter(!(Gene %in% c('AT1G58807','AT1G58848','AT1G59124','AT1G59218')))
hv_names <- HV$Gene
hv_geneset <- GeneSet(hv_names, geneIdType=SymbolIdentifier())

NONHV <- table %>% filter(HV == 'non-hv')
nonhv_names <- NONHV$Gene %>% unique()
nonhv_geneset <- GeneSet(nonhv_names, geneIdType=SymbolIdentifier())
```

This packages does analysis by sample, not on averaged biological replicates. Loading a raw TPM matrix. Then, create the ranked gene object, ranked, and score the hv gene set and the nonhv gene set. From here, generate a null distro and plot our p values 
```{r}
TPM <- read.table("C:\\Users\\chand\\Box Sync\\Krasileva_Lab\\Research\\chandler\\Krasileva Lab\\E14\\tpm_matrix.csv", header=TRUE, sep=",", row.names=2) %>% subset(select=c(-X))

ranked <- rankGenes(TPM)

hv_sing <- simpleScore(ranked, upSet=hv_geneset)
nonhv_sing <- simpleScore(ranked, nonhv_geneset)

hv_null <- generateNull(rankData=ranked, upSet=hv_geneset)
hv_p <- getPvals(hv_null, hv_sing)
plotNull(hv_null, hv_sing, hv_p, sampleNames = names(hv_p)[1:4], textSize=0.5)
```

```{r}
nonhv_null <- generateNull(rankData=ranked, upSet=nonhv_geneset)
nonhv_p <- getPvals(nonhv_null, nonhv_sing)
plotNull(nonhv_null, nonhv_sing, nonhv_p, sampleNames = names(nonhv_p)[1:4], textSize=0.5)
```

For methylation and TE distance, write a function to calculate a p value for enrichment tests by using a permutation test 
```{r}
table[2]
# first, calculate the observed value
observe <- function(df, col_index, hv_status){
  observed <- mean(df%>%filter(HV==hv_status)%>%pull(col_index)%>%na.omit()) - 
    mean(df %>% filter(HV=='all_genes')%>%pull(col_index)%>%na.omit())
  observed
}

permute <- function(df, col_index, hv_status) {
  # build null distribution
  permutation = replicate(10000, {
    df <- df %>% drop_na(col_index)
    sample_small <- df[sample(nrow(df), nrow(df[df$HV == hv_status,]) , replace = FALSE), ] # sample the size of hvNLRs
    sample_large <- df[! rownames(df) %in% rownames(sample_small), ] # sample the rest
    mean(sample_small %>% pull(col_index))-mean(sample_large %>% pull(col_index)) # get expected mean
})
  permutation
}

p<-permute(table, 3, 'hv')
o<-observe(table, 3, 'hv')

mean(o<p)

p_calc <- function(df, col_index){
  o <- observe(df, col_index, 'hv')
  p <- permute(df, col_index, 'hv')
  pval <- mean(o > p)
  
  o2 <- observe(df, col_index, 'non-hv')
  p2 <- permute(df, col_index, 'non-hv')
  pval2 <- mean(o2 > p2)
  
  print(paste(colnames(df)[col_index]))
  print(paste('hv_p: ', pval, ' nonhv_p:', pval2))
}

p_calc(table, 4)
p_calc(table, 5)
```

For TE distance, also check the median: 
```{r}
observe_med <- function(df, col_index, hv_status){
  observed <- median(df%>%filter(HV==hv_status)%>%pull(col_index)%>%na.omit()) - 
    median(df %>% filter(HV=='all_genes')%>%pull(col_index)%>%na.omit())
  observed
}

permute_med <- function(df, col_index, hv_status) {
  # build null distribution
  permutation = replicate(10000, {
    df <- df %>% drop_na(col_index)
    sample_small <- df[sample(nrow(df), nrow(df[df$HV == hv_status,]) , replace = FALSE), ] # sample the size of hvNLRs
    sample_large <- df[! rownames(df) %in% rownames(sample_small), ] # sample the rest
    median(sample_small %>% pull(col_index))-median(sample_large %>% pull(col_index)) # get expected mean
})
  permutation
}

p_calc_med <- function(df, col_index){
  o <- observe_med(df, col_index, 'hv')
  p <- permute_med(df, col_index, 'hv')
  pval <- mean(o > p)
  
  o2 <- observe_med(df, col_index, 'non-hv')
  p2 <- permute_med(df, col_index, 'non-hv')
  pval2 <- mean(o2 > p2)
  
  print(paste(colnames(df)[col_index], ' median'))
  print(paste('hv_p: ', pval, ' nonhv_p:', pval2))
}

p_calc_med(table, 5)
```


A potential bias for CG methylation is the number of high coverage CGs per gene. This is on a per-sample basis. First, test the per sample significance, then weight based on CGs per gene. 
```{r}
#load the per sample methylation files 
SRR17281085 <- readxl::read_xlsx(path="C://Users//chand//Box Sync//Krasileva_Lab//Research//chandler//Krasileva Lab//E14//e14_R//SRR17281085_per_gene_meth_count.xlsx", skip=2, col_names = c('Index', 'Chrom', 'Gene', 'mean_percent_methylation', 'count'))
SRR17281086 <- readxl::read_xlsx(path="C://Users//chand//Box Sync//Krasileva_Lab//Research//chandler//Krasileva Lab//E14//e14_R//SRR17281086_per_gene_meth_count.xlsx", skip=2, col_names = c('Index', 'Chrom', 'Gene', 'mean_percent_methylation', 'count'))
SRR17281087 <- readxl::read_xlsx(path="C://Users//chand//Box Sync//Krasileva_Lab//Research//chandler//Krasileva Lab//E14//e14_R//SRR17281087_per_gene_meth_count.xlsx", skip=2, col_names = c('Index', 'Chrom', 'Gene', 'mean_percent_methylation', 'count'))
SRR17281088 <- readxl::read_xlsx(path="C://Users//chand//Box Sync//Krasileva_Lab//Research//chandler//Krasileva Lab//E14//e14_R//SRR17281088_per_gene_meth_count.xlsx", skip=2, col_names = c('Index', 'Chrom', 'Gene', 'mean_percent_methylation', 'count'))

#clean up 
samples <- list(SRR17281085, SRR17281086, SRR17281087, SRR17281088)
names(samples) <- c('SRR17281085', 'SRR17281086', 'SRR17281087', 'SRR17281088')

clean <- function(df) {
  df2 <- df %>% merge(table, by='Gene', all=TRUE)
  df2$HV <- factor(df2$HV , levels=c("all_genes", "non-hv", "hv"))
  df3 <- df2 %>% subset(select=c('Gene', 'HV', 'mean_percent_methylation', 'count')) %>%
    filter(!is.na(mean_percent_methylation))
  df3
}

clean_samples <- lapply(names(samples), function(x) clean(samples[[x]]))
names(clean_samples) <- c('SRR17281085', 'SRR17281086', 'SRR17281087', 'SRR17281088')
```
```{r}
lapply(names(clean_samples), function(x) p_calc(clean_samples[[x]], 3))
```

The kernel density estimation computes kernel density estimates. Often shortened to KDE, it’s a technique that let’s you create a smooth curve given a set of data. So here, it's taking in my # of mappable CG sites per HV gene, and returning a density curve. 

The approxfun function returns a list of points which linearly interpolate given data points. Returns a function performing linear or constant interpolation of the given data points. Linear interpolation is a method of calculating intermediate data between known values by conceptually drawing a straight line between two adjacent known values.

Repeat the CG count weighted permutation test on all four samples: 
```{r}
# calculate mean difference for all sampled dsns
get_mean_difference <- function(x) {
  x_not <- all_genes[!all_genes %in% x]
  x_srs <- test[test$Gene %in% x, ]
  x_not_srs <- test[! test$Gene %in% x, ]
  return(mean(x_srs$mean_percent_methylation)-mean(x_not_srs$mean_percent_methylation))
}

density_sample <- function(df, hv_status){
  split_df <- df %>% filter(HV == hv_status)
  
  #calculate CG count density KDE function 
  d <- density(split_df$count)
  density_function <- approxfun(d)
  
  # write probabilities, and write NAs to zero as they are outliers in CG content (90+ per gene)
  probabilities <- density_function(df$count)
  probabilities[is.na(probabilities)] <- 0
  
  # sample genes, with weights according to their number of CGs, according to above function
  all_genes <- df$Gene
  sampled_genes <- data.frame(replicate(10000, sample(all_genes, size = nrow(split_df), replace = FALSE, 
                                                    prob = probabilities)))
  
  return(sampled_genes)
  }

test_nhv <- density_sample(clean_samples[[1]], 'non-hv')

pval <- function(sampled_df, hv_status, observed){
  x <- lapply(sampled_df, get_mean_difference)
  df_x <- t(data.frame(x))
  p_val <- mean(df_x[,1] < observed)
  
  return(p_val)
}
```

```{r}
hv_sampled_genes <- lapply(names(clean_samples), function(x) density_sample(clean_samples[[x]], 'hv'))
observed_hv <- lapply(names(clean_samples), function(x) observe(clean_samples[[x]], 3, 'hv'))

pval(hv_sampled_genes[[1]], 'hv', observed_hv[[1]])
pval(hv_sampled_genes[[2]], 'hv', observed_hv[[2]])
pval(hv_sampled_genes[[3]], 'hv', observed_hv[[3]])
pval(hv_sampled_genes[[4]], 'hv', observed_hv[[4]])
```

```{r}
nhv_sampled_genes <- lapply(names(clean_samples), function(x) density_sample(clean_samples[[x]], 'non-hv'))
observed_nhv <- lapply(names(clean_samples), function(x) observe(clean_samples[[x]], 3, 'non-hv'))

pval(nhv_sampled_genes[[1]], 'non-hv', observed_nhv[[1]])
pval(nhv_sampled_genes[[2]], 'non-hv', observed_nhv[[2]])
pval(nhv_sampled_genes[[3]], 'non-hv', observed_nhv[[3]])
pval(nhv_sampled_genes[[4]], 'non-hv', observed_nhv[[4]])
```

